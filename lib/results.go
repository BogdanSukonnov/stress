package stress

import (
	"encoding/json"
	"io"
	"sort"
	"time"
)

// Result represents the metrics defined out of an http.Response
// generated by each target hit
type Result struct {
	Code      uint16
	Timestamp time.Time
	Latency   time.Duration
	BytesOut  uint64
	BytesIn   uint64
	Error     string
}

// Results is a slice of Result structs with encoding,
// decoding and sorting behavior attached
type Results []Result

// Encode encodes the results and writes it to an io.Writer
// returning an error in case of failure
func (r Results) Encode(out io.Writer) error {
	/*
		for index, result := range r {
			_, err := fmt.Fprintf(out,
				"{id:%d code:%d timestamp:%s latency:%s bytesout:%d bytesin:%d error:%s}\n", index, result.Code, result.Timestamp.String(), result.Latency.String(), result.BytesOut, result.BytesIn, result.Error)
			if err != nil {
				break
				return err
			}
		}
		return nil
	*/
	//return gob.NewEncoder(out).Encode(r)
	return json.NewEncoder(out).Encode(r)
}

// Decode reads data from an io.Reader and decodes it into a Results struct
// returning an error in case of failure
func (r *Results) Decode(in io.Reader) error {
	return json.NewDecoder(in).Decode(r)
}

// Sort sorts Results by Timestamp in ascending order and returns
// the sorted slice
func (r Results) Sort() Results {
	sort.Sort(r)
	return r
}

func (r Results) Len() int           { return len(r) }
func (r Results) Less(i, j int) bool { return r[i].Timestamp.Before(r[j].Timestamp) }
func (r Results) Swap(i, j int)      { r[i], r[j] = r[j], r[i] }
